\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{xcolor}
\usepackage[colorlinks=true]{hyperref}
\usepackage{fancyhdr}
\usepackage{setspace}

% Define code styling
\lstset{
language=C++,
basicstyle=\ttfamily\small,
numbers=left,
numberstyle=\tiny\color{gray},
commentstyle=\color{gray},
keywordstyle=\color{blue},
stringstyle=\color{red},
tabsize=2,
showstringspaces=false,
breaklines=true,
captionpos=b,
caption={Code Snippet}
}

\title{Runtime Analysis of 0/1 Knapsack Problem Algorithms}\\
\author{Abhishek Beniwal, Aditya Purohit, Rahul Paul, Vaidya Parth \\
\small{Roll no.: 202411002, 202411003, 202411078, 202411095} \\
\small{Prof: Dr. Pareek} \\
\small{Course : CS/IT-203} \\
\small{Date : \today}}\\
\date{}

\begin{document}

\maketitle
\newpage

\section{Introduction}
0/1 Knapsack: pick items (value, weight) to maximize value under capacity. We compare five short C++ variants and their runtimes.

\subsection*{1. Recursive (no memo)}
Brute recursion: try include/exclude.
\begin{lstlisting}
int pickRec(int load[], int gain[], int items, int room)
{
    if (items == 0 || room == 0) return 0;
    if (load[items - 1] > room) return pickRec(load, gain, items - 1, room);
    return max(gain[items - 1] + pickRec(load, gain, items - 1, room - load[items - 1]),
               pickRec(load, gain, items - 1, room));
}
\end{lstlisting}
\textbf{Time}: $O(2^n)$.

\subsection*{2. Top-down memo}
Memoize states \((items, room)\).
\begin{lstlisting}
int pickMemo(int load[], int gain[], int items, int room, vector<vector<int>> &ledger)
{
    if (items == 0 || room == 0) return 0;
    if (ledger[items][room] != -1) return ledger[items][room];
    if (load[items - 1] > room) return ledger[items][room] = pickMemo(load, gain, items - 1, room, ledger);
    return ledger[items][room] = max(gain[items - 1] + pickMemo(load, gain, items - 1, room - load[items - 1], ledger),
                                     pickMemo(load, gain, items - 1, room, ledger));
}
\end{lstlisting}
\textbf{Time/Space}: $O(nW)$/$O(nW)$.

\subsection*{3. Bottom-up (tab)}
Iterative DP table.
\begin{lstlisting}
int packTab(int load[], int gain[], int items, int room)
{
    vector<vector<int>> ledger(items + 1, vector<int>(room + 1, 0));
    for (int it = 1; it <= items; it++)
        for (int cap = 1; cap <= room; cap++)
            if (load[it - 1] <= cap)
                ledger[it][cap] = max(gain[it - 1] + ledger[it - 1][cap - load[it - 1]], ledger[it - 1][cap]);
            else
                ledger[it][cap] = ledger[it - 1][cap];
    return ledger[items][room];
}
\end{lstlisting}
\textbf{Time/Space}: $O(nW)$/$O(nW)$.

\subsection*{4. 2D DP (vectors)}
Same as tab with vectors.
\begin{lstlisting}
int packGrid(int room, vector<int> &load, vector<int> &gain, int items)
{
    vector<vector<int>> ledger(items + 1, vector<int>(room + 1, 0));
    for (int it = 1; it <= items; it++)
        for (int cap = 1; cap <= room; cap++)
            ledger[it][cap] = (load[it - 1] <= cap)
                ? max(gain[it - 1] + ledger[it - 1][cap - load[it - 1]], ledger[it - 1][cap])
                : ledger[it - 1][cap];
    return ledger[items][room];
}
\end{lstlisting}
\textbf{Time/Space}: $O(nW)$/$O(nW)$.

\subsection*{5. 1D DP (space-opt)}
Single row DP, loop w backward.
\begin{lstlisting}
int packRow(int room, vector<int> &load, vector<int> &gain, int items)
{
    vector<int> line(room + 1, 0);
    for (int it = 0; it < items; it++)
        for (int cap = room; cap >= load[it]; cap--)
            line[cap] = max(line[cap], line[cap - load[it]] + gain[it]);
    return line[room];
}
\end{lstlisting}
\textbf{Time/Space}: $O(nW)$/$O(W)$.

\newpage
\section{Performance and Complexity Summary}

\subsection*{Theoretical Complexity}
Summary:
\begin{itemize}
    \item \textbf{Recursive}: $O(2^n)$ Time, $O(n)$ Space (for recursion stack)
    \item \textbf{Memoization}: $O(n \times W)$ Time, $O(n \times W)$ Space
    \item \textbf{Tabulation / 2D DP}: $O(n \times W)$ Time, $O(n \times W)$ Space
    \item \textbf{1D DP (Space-Optimized)}: $O(n \times W)$ Time, $O(W)$ Space
\end{itemize}
1D uses less memory and is typically faster.

\section{Runtime Performance Graph}
2D vs 1D runtime trend.

\begin{figure}[h!]
\centering
\includegraphics[width=0.9\textwidth]{runtime_graph.png}
\caption{Runtime Comparison: 2D DP vs 1D Space-Optimized DP}
\label{fig:runtime_graph}
\end{figure}

1D is consistently faster across sizes.

\section{Conclusion}
Prefer 1D DP: same time, much less memory, faster in practice.

\end{document}